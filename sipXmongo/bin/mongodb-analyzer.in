#!/bin/env python

# Copyright (c) 2013 eZuce, Inc. All rights reserved. 
# Contributed to SIPfoundry under a Contributor Agreement 
# 
# This software is free software; you can redistribute it and/or modify it under 
# the terms of the Affero General Public License (AGPL) as published by the 
# Free Software Foundation; either version 3 of the License, or (at your option) 
# any later version. 
# 
# This software is distributed in the hope that it will be useful, but WITHOUT 
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
# FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more 
# details.

# Analyze the status of a set of mongo clusters and decide what operations
# are need to bring a cluster to a healthy state.  This script is mostly 
# logic based and has no need to connect to mongo servers or operate with
# any operating system.

# Meant to be used as the second part of the set of three mongodb
# detailed below and in each script:
#
# Part 1.) mongodb-status assesses the health of a system
# Part 2.) mongodb-analyzer takes the results from mongodb-status 
#  and comes with with a set of recommended tasks to bring the
#  cluster back into a health state if it decided it's not in a
#  healthy state. Tasks are broken up into a list of zero or more
#  tasks for each server.
# Part 3.) mongodb-admin then takes a set of tasks interpretted by
#   an admin at the command prompt or fed into a user interface 
#   for the admin to select which tasks they's like to perform on
#    which server.  The tasks are then passed to the mongodb-admin
#    script on the appropriate server to execute.


# Deprecation note: intentionally using deprecated Connection class because 
# class MongoClient is not available yet in pymongo on centos 6
import sys
import traceback
import logging
import argparse
import json

action_models = []

class ActionMeta:
    def __init__(self, hosts, cluster_states, server_states):
        self.cluster_states = cluster_states
        self.server_states = server_states
        self.actions = {}

    def chompPort(self, host_port):
        return host_port.partition(':')[0]

    def addAction(self, host, action):
        if host not in self.actions:
            self.actions[host] = [action]
        else:
            self.actions[host].append(action)

    def primaries(self):
        primaries = []
        for host, states in self.server_states.items():
            if 'PRIMARY' in states:
                primaries.append(host)
        return primaries

class  PrimaryActions:
    def actions(self, meta):
        self.elect_primary = 'NO_PRIMARY' in meta.cluster_states
        self.multi_primary = 'MULTIPLE_PRIMARIES' in meta.cluster_states
        primaries = []
        for host_port, states in meta.server_states.items():
            host = meta.chompPort(host_port)
            if self.elect_primary and 'SECONDARY' in states:
                meta.addAction(host, 'FORCE_PRIMARY')
            if 'BAD_REPLSET_DATABASE' in states:
                meta.addAction(host, 'RESET_LOCAL_DATABASE')
            if 'BAD_REPLSET_ARBITER' in states:
                meta.addAction(host, 'RESET_LOCAL_ARBITER')
            elif self.multi_primary and 'PRIMARY' in states:
                primaries.append(host)

        # 2nd pass we option to reset databases
        if len(primaries) > 2:
            for primary in primaries:
                meta.addAction(primary, 'RESET_DATABASE')
                
action_models.append(PrimaryActions())

class ServerActions:
    def actions(self, meta):
        for host_port, states in meta.server_states.items():
            host = meta.chompPort(host_port)
            if 'UNAVAILABLE_DATABASE' in states:
                    meta.addAction(host, 'START_DATABASE')
            if 'UNAVAILABLE_ARBITER' in states:
                    meta.addAction(host, 'START_ARBITER')
action_models.append(ServerActions())

class AddRemoveActions:
    def actions(self, meta):
        primaries = meta.primaries()
        if len(primaries) == 1:
            for host_port, states in meta.server_states.items():
                host = meta.chompPort(host_port)
                primary = meta.chompPort(primaries[0])
                if 'MISSING_ARBITER' in states:
                    meta.addAction(primary, 'ADD_ARBITER ' + host_port)
                if 'MISSING_DATABASE' in states:
                    meta.addAction(primary, 'ADD_DATABASE ' + host_port)

action_models.append(AddRemoveActions())

class MongoActionModel:
    def __init__(self, io):
        lines = io.readlines()
        self.cluster_states = json.loads(lines[0])
        self.server_states = json.loads(lines[1])

    def analyze(self):
        hosts = self.server_states.keys()
        meta = ActionMeta(hosts, self.cluster_states, self.server_states)
        for action_model in action_models:
            action_model.actions(meta)

        sys.stdout.write(json.dumps(meta.actions, indent=4, separators=(',', ': ')))
        print

if __name__ == '__main__':
    c = None
    # Parse arguments
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Mongo/sipXecs administration tools'
        )
    parser.formatter_class = argparse.ArgumentDefaultsHelpFormatter
    parser.add_argument('--verbose', action="store_true", default=False,
                help='verbose output')
    args = vars(parser.parse_args())

    try:
        level = None
        if args['verbose']:
            level = logging.DEBUG        
        logging.basicConfig(
            level=level,
            format='.%(message)s'
        )

        actions = MongoActionModel(sys.stdin)
        actions.analyze()

    except :
        sys.stderr.write(traceback.format_exc())
        sys.stderr.write('\n')
        exit(1)
            
    finally:
        if c != None:
            logging.debug('closing connection')
            c.close()
